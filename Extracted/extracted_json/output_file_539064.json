{
    "title": "A Theoretically Grounded Application of Dropout in",
    "content": {
        "page_content": "A Theoretically Grounded Application of Dropout in\nRecurrent Neural Networks\nYarin Gal\nUniversity of Cambridge\n{yg279,zg201}@cam.ac.uk\nZoubin Ghahramani\nAbstract\nRecurrent neural networks (RNNs) stand at the forefront of many recent develop-\nments in deep learning. Yet a major difﬁculty with these models is their tendency to\noverﬁt, with dropout shown to fail when applied to recurrent layers. Recent results\nat the intersection of Bayesian modelling and deep learning offer a Bayesian inter-\npretation of common deep learning techniques such as dropout. This grounding of\ndropout in approximate Bayesian inference suggests an extension of the theoretical\nresults, offering insights into the use of dropout with RNN models. We apply this\nnew variational inference based dropout technique in LSTM and GRU models,\nassessing it on language modelling and sentiment analysis tasks. The new approach\noutperforms existing techniques, and to the best of our knowledge improves on the\nsingle model state-of-the-art in language modelling with the Penn Treebank (73.4\ntest perplexity). This extends our arsenal of variational tools in deep learning.\n1 Introduction\nRecurrent neural networks (RNNs) are sequence-based models of key importance for natural language\nunderstanding, language generation, video processing, and many other tasks [1–3]. The model’s input\nis a sequence of symbols, where at each time step a simple neural network (RNN unit) is applied to a\nsingle symbol, as well as to the network’s output from the previous time step. RNNs are powerful\nmodels, showing superb performance on many tasks, but overﬁt quickly. Lack of regularisation in\nRNN models makes it difﬁcult to handle small data, and to avoid overﬁtting researchers often use\nearly stopping, or small and under-speciﬁed models [4].\nDropout is a popular regularisation technique with deep networks [ 5, 6] where network units are\nrandomly masked during training (dropped). But the technique has never been applied successfully\nto RNNs. Empirical results have led many to believe that noise added to recurrent layers (connections\nbetween RNN units) will be ampliﬁed for long sequences, and drown the signal [4]. Consequently,\nexisting research has concluded that the technique should be used with the inputs and outputs of the\nRNN alone [4, 7–10]. But this approach still leads to overﬁtting, as is shown in our experiments.\nRecent results at the intersection of Bayesian research and deep learning offer interpretation of\ncommon deep learning techniques through Bayesian eyes [ 11–16]. This Bayesian view of deep\nlearning allowed the introduction of new techniques into the ﬁeld, such as methods to obtain principled\nuncertainty estimates from deep learning networks [14, 17]. Gal and Ghahramani [14] for example\nshowed that dropout can be interpreted as a variational approximation to the posterior of a Bayesian\nneural network (NN). Their variational approximating distribution is a mixture of two Gaussians\nwith small variances, with the mean of one Gaussian ﬁxed at zero. This grounding of dropout in\napproximate Bayesian inference suggests that an extension of the theoretical results might offer\ninsights into the use of the technique with RNN models.\nHere we focus on common RNN models in the ﬁeld (LSTM [ 18], GRU [19]) and interpret these\nas probabilistic models, i.e. as RNNs with network weights treated as random variables, and with\narXiv:1512.05287v5  [stat.ML]  5 Oct 2016xt\nyt\nxt−1\nyt−1\nxt+1\nyt+1\n(a) Naive dropout RNN\nxt\nyt\nxt−1\nyt−1\nxt+1\nyt+1\n(b) Variational RNN\nFigure 1: Depiction of the dropout technique following our Bayesian interpretation (right)\ncompared to the standard technique in the ﬁeld (left). Each square represents an RNN unit, with\nhorizontal arrows representing time dependence (recurrent connections). Vertical arrows represent\nthe input and output to each RNN unit. Coloured connections represent dropped-out inputs, with\ndifferent colours corresponding to different dropout masks. Dashed lines correspond to standard\nconnections with no dropout. Current techniques (naive dropout, left) use different masks at different\ntime steps, with no dropout on the recurrent layers. The proposed technique (Variational RNN, right)\nuses the same dropout mask at each time step, including the recurrent layers.\nsuitably deﬁned likelihood functions. We then perform approximate variational inference in these\nprobabilistic Bayesian models (which we will refer to as Variational RNNs). Approximating the\nposterior distribution over the weights with a mixture of Gaussians (with one component ﬁxed at\nzero and small variances) will lead to a tractable optimisation objective. Optimising this objective is\nidentical to performing a new variant of dropout in the respective RNNs.\nIn the new dropout variant, we repeat the same dropout mask at each time step for both inputs, outputs,\nand recurrent layers (drop the same network units at each time step). This is in contrast to the existing\nad hoc techniques where different dropout masks are sampled at each time step for the inputs and\noutputs alone (no dropout is used with the recurrent connections since the use of different masks\nwith these connections leads to deteriorated performance). Our method and its relation to existing\ntechniques is depicted in ﬁgure 1. When used with discrete inputs (i.e. words) we place a distribution\nover the word embeddings as well. Dropout in the word-based model corresponds then to randomly\ndropping word types in the sentence, and might be interpreted as forcing the model not to rely on\nsingle words for its task.\nWe next survey related literature and background material, and then formalise our approximate\ninference for the Variational RNN, resulting in the dropout variant proposed above. Experimental\nresults are presented thereafter.\n2 Related Research\nIn the past few years a considerable body of work has been collected demonstrating the negative\neffects of a naive application of dropout in RNNs’ recurrent connections. Pachitariu and Sahani [7],\nworking with language models, reason that noise added in the recurrent connections of an RNN leads\nto model instabilities. Instead, they add noise to the decoding part of the model alone. Bayer et al. [8]\napply a deterministic approximation of dropout (fast dropout) in RNNs. They reason that with dropout,\nthe RNN’s dynamics change dramatically, and that dropout should be applied to the “non-dynamic”\nparts of the model – connections feeding from the hidden layer to the output layer. Pham et al. [9]\nassess dropout with handwriting recognition tasks. They conclude that dropout in recurrent layers\ndisrupts the RNN’s ability to model sequences, and that dropout should be applied to feed-forward\nconnections and not to recurrent connections. The work by Zaremba, Sutskever, and Vinyals [4] was\ndeveloped in parallel to Pham et al.[9]. Zaremba et al. [4] assess the performance of dropout in RNNs\non a wide series of tasks. They show that applying dropout to the non-recurrent connections alone\n2results in improved performance, and provide (as yet unbeaten) state-of-the-art results in language\nmodelling on the Penn Treebank. They reason that without dropout only small models were used\nin the past in order to avoid overﬁtting, whereas with the application of dropout larger models can\nbe used, leading to improved results. This work is considered a reference implementation by many\n(and we compare to this as a baseline below). Bluche et al. [10] extend on the previous body of work\nand perform exploratory analysis of the performance of dropout before, inside, and after the RNN’s\nunit. They provide mixed results, not showing signiﬁcant improvement on existing techniques. More\nrecently, and done in parallel to this work, Moon et al. [20] suggested a new variant of dropout in\nRNNs in the speech recognition community. They randomly drop elements in the LSTM’s internal\ncell ct and use the same mask at every time step. This is the closest to our proposed approach\n(although fundamentally different to the approach we suggest, explained in §4.1), and we compare to\nthis variant below as well.\nExisting approaches are based on an empirical experimentation with different ﬂavours of dropout,\nfollowing a process of trial-and-error. These approaches have led many to believe that dropout\ncannot be extended to a large number of parameters within the recurrent layers, leaving them with\nno regularisation. In contrast to these conclusions, we show that it is possible to derive a variational\ninference based variant of dropout which successfully regularises such parameters, by grounding our\napproach in recent theoretical research.\n3 Background\nWe review necessary background in Bayesian neural networks and approximate variational inference.\nBuilding on these ideas, in the next section we propose approximate inference in the probabilistic\nRNN which will lead to a new variant of dropout.\n3.1 Bayesian Neural Networks\nGiven training inputs X = {x1,..., xN }and their corresponding outputs Y = {y1,..., yN }, in\nBayesian (parametric) regression we would like to infer parameters ω of a function y = fω(x) that\nare likely to have generated our outputs. What parameters are likely to have generated our data?\nFollowing the Bayesian approach we would put some prior distribution over the space of parameters,\np(ω). This distribution represents our prior belief as to which parameters are likely to have generated\nour data. We further need to deﬁne a likelihood distribution p(y|x,ω). For classiﬁcation tasks we\nmay assume a softmax likelihood,\np\n(\ny= d|x,ω\n)\n= Categorical\n(\nexp(fω\nd (x))/\n∑\nd′\nexp(fω\nd′ (x))\n)\nor a Gaussian likelihood for regression. Given a dataset X,Y, we then look for the posterior\ndistribution over the space of parameters: p(ω|X,Y). This distribution captures how likely various\nfunction parameters are given our observed data. With it we can predict an output for a new input\npoint x∗by integrating\np(y∗|x∗,X,Y) =\n∫\np(y∗|x∗,ω)p(ω|X,Y)dω. (1)\nOne way to deﬁne a distribution over a parametric set of functions is to place a prior distribution over\na neural network’sweights, resulting in a Bayesian NN [21, 22]. Given weight matrices Wi and bias\nvectors bi for layer i, we often place standard matrix Gaussian prior distributions over the weight\nmatrices, p(Wi) =N(0,I) and often assume a point estimate for the bias vectors for simplicity.\n3.2 Approximate Variational Inference in Bayesian Neural Networks\nWe are interested in ﬁnding the distribution of weight matrices (parametrising our functions) that have\ngenerated our data. This is the posterior over the weights given our observables X,Y: p(ω|X,Y).\nThis posterior is not tractable in general, and we may use variational inference to approximate it (as\nwas done in [23–25, 12]). We need to deﬁne an approximating variational distribution q(ω), and then\nminimise the KL divergence between the approximating distribution and the full posterior:\nKL\n(\nq(ω)||p(ω|X,Y)\n)\n∝−\n∫\nq(ω) logp(Y|X,ω)dω + KL(q(ω)||p(ω))\n3= −\nN∑\ni=1\n∫\nq(ω) logp(yi|fω(xi))dω + KL(q(ω)||p(ω)). (2)\nWe next extend this approximate variational inference to probabilistic RNNs, and use a q(ω) distribu-\ntion that will give rise to a new variant of dropout in RNNs.\n4 Variational Inference in Recurrent Neural Networks\nIn this section we will concentrate on simple RNN models for brevity of notation. Derivations for\nLSTM and GRU follow similarly. Given input sequence x = [x1,..., xT ] of length T, a simple RNN\nis formed by a repeated application of a function fh. This generates a hidden state ht for time step t:\nht = fh(xt,ht−1) =σ(xtWh + ht−1Uh + bh)\nfor some non-linearity σ. The model output can be deﬁned, for example, as fy(hT ) =hT Wy + by.\nWe view this RNN as a probabilistic model by regardingω = {Wh,Uh,bh,Wy,by}as random\nvariables (following normal prior distributions). To make the dependence on ω clear, we write fω\ny\nfor fy and similarly for fω\nh . We deﬁne our probabilistic model’s likelihood as above (section 3.1).\nThe posterior over random variables ω is rather complex, and we use variational inference with\napproximating distribution q(ω) to approximate it.\nEvaluating each sum term in eq. (2) above with our RNN model we get\n∫\nq(ω) logp(y|fω\ny (hT ))dω =\n∫\nq(ω) logp\n(\ny\n⏐⏐⏐⏐fω\ny\n(\nfω\nh (xT ,hT−1)\n))\ndω\n=\n∫\nq(ω) logp\n(\ny\n⏐⏐⏐⏐fω\ny\n(\nfω\nh (xT ,fω\nh (...fω\nh (x1,h0)...))\n))\ndω\nwith h0 = 0. We approximate this with Monte Carlo (MC) integration with a single sample:\n≈log p\n(\ny\n⏐⏐⏐⏐f ˆω\ny\n(\nf ˆω\nh (xT ,f ˆω\nh (...f ˆω\nh (x1,h0)...))\n))\n, ˆω ∼q(ω)\nresulting in an unbiased estimator to each sum term.\nThis estimator is plugged into equation (2) to obtain our minimisation objective\nL≈−\nN∑\ni=1\nlog p\n(\nyi\n⏐⏐⏐⏐f ˆωi\ny\n(\nf ˆωi\nh (xi,T ,f ˆωi\nh (...f ˆωi\nh (xi,1,h0)...))\n))\n+ KL(q(ω)||p(ω)). (3)\nNote that for each sequence xi we sample a new realisation ˆωi = {ˆWi\nh, ˆUi\nh,ˆbi\nh,ˆWi\ny,ˆbi\ny}, and that\neach symbol in the sequence xi = [xi,1,..., xi,T ] is passed through the function f ˆωi\nh with the same\nweight realisations ˆWi\nh, ˆUi\nh,ˆbi\nh used at every time stept≤T.\nFollowing [17] we deﬁne our approximating distribution to factorise over the weight matrices and\ntheir rows in ω. For every weight matrix row wk the approximating distribution is:\nq(wk) =pN(wk; 0,σ2I) + (1−p)N(wk; mk,σ2I)\nwith mk variational parameter (row vector), pgiven in advance (the dropout probability), and small\nσ2. We optimise over mk the variational parameters of the random weight matrices; these correspond\nto the RNN’s weight matrices in the standard view1. The KL in eq. (3) can be approximated as L2\nregularisation over the variational parameters mk [17].\nEvaluating the model outputf ˆω\ny (·) with sample ˆω ∼q(ω) corresponds to randomly zeroing (masking)\nrows in each weight matrix W during the forward pass – i.e. performing dropout. Our objective Lis\nidentical to that of the standard RNN. In our RNN setting with a sequence input, each weight matrix\nrow is randomly masked once, and importantly the same mask is used through all time steps.2\n1Graves et al. [26] further factorise the approximating distribution over the elements of each row, and use a\nGaussian approximating distribution with each element (rather than a mixture); the approximating distribution\nabove seems to give better performance, and has a close relation with dropout [17].\n2In appendix A we discuss the relation of our dropout interpretation to the ensembling one.\n4Predictions can be approximated by either propagating the mean of each layer to the next (referred to\nas the standard dropout approximation), or by approximating the posterior in eq. (1) with q(ω),\np(y∗|x∗,X,Y) ≈\n∫\np(y∗|x∗,ω)q(ω)dω ≈ 1\nK\nK∑\nk=1\np(y∗|x∗,ˆωk) (4)\nwith ˆωk ∼q(ω), i.e. by performing dropout at test time and averaging results (MC dropout).\n4.1 Implementation and Relation to Dropout in RNNs\nImplementing our approximate inference is identical to implementing dropout in RNNs with the\nsame network units dropped at each time step , randomly dropping inputs, outputs, and recurrent\nconnections. This is in contrast to existing techniques, where different network units would be\ndropped at different time steps, and no dropout would be applied to the recurrent connections (ﬁg. 1).\nCertain RNN models such as LSTMs and GRUs use different gates within the RNN units. For\nexample, an LSTM is deﬁned using four gates: “input”, “forget”, “output”, and “input modulation”,\ni = sigm\n(\nht−1Ui + xtWi\n)\nf = sigm\n(\nht−1Uf + xtWf\n)\no = sigm\n(\nht−1Uo + xtWo\n)\ng = tanh\n(\nht−1Ug + xtWg\n)\nct = f ◦ct−1 + i ◦g ht = o ◦tanh(ct) (5)\nwith ω = {Wi,Ui,Wf ,Uf ,Wo,Uo,Wg,Ug}weight matrices and ◦the element-wise product.\nHere an internal state ct (also referred to as cell) is updated additively.\nAlternatively, the model could be re-parametrised as in [26]:\n\n\ni\nf\no\ng\n\n=\n\n\nsigm\nsigm\nsigm\ntanh\n\n\n((\nxt\nht−1\n)\n·W\n)\n(6)\nwith ω = {W}, W a matrix of dimensions 2Kby 4K(Kbeing the dimensionality of xt). We name\nthis parametrisation a tied-weights LSTM (compared to the untied-weights LSTM in eq. (5)).\nEven though these two parametrisations result in the same deterministic model, they lead to different\napproximating distributions q(ω). With the ﬁrst parametrisation one could use different dropout\nmasks for different gates (even when the same input xt is used). This is because the approximating\ndistribution is placed over the matrices rather than the inputs: we might drop certain rows in one\nweight matrix W applied to xt and different rows in another matrix W′applied to xt. With the\nsecond parametrisations we would place a distribution over the single matrix W. This leads to a\nfaster forward-pass, but with slightly diminished results as we will see in the experiments section.\nIn more concrete terms, we may write our dropout variant with the second parametrisation (eq.(6)) as\n\n\ni\nf\no\ng\n\n=\n\n\nsigm\nsigm\nsigm\ntanh\n\n\n((\nxt ◦zx\nht−1 ◦zh\n)\n·W\n)\n(7)\nwith zx,zh random masks repeated at all time steps (and similarly for the parametrisation in eq. (5)).\nIn comparison, Zaremba et al. [4]’s dropout variant replaceszx in eq. (7) with the time-dependent zt\nx\nwhich is sampled anew every time step (whereas zh is removed and the recurrent connection ht−1 is\nnot dropped):\n\n\ni\nf\no\ng\n\n=\n\n\nsigm\nsigm\nsigm\ntanh\n\n\n((\nxt ◦zt\nx\nht−1\n)\n·W\n)\n. (8)\nOn the other hand, Moon et al. [20]’s dropout variant changes eq. (5) by adapting the internal cell\nct = ct ◦zc (9)\nwith the same mask zc used at all time steps. Note that unlike [ 20], by viewing dropout as an\noperation over the weights our technique trivially extends to RNNs and GRUs.\n54.2 Word Embeddings Dropout\nIn datasets with continuous inputs we often apply dropout to the input layer – i.e. to the input vector\nitself. This is equivalent to placing a distribution over the weight matrix which follows the input and\napproximately integrating over it (the matrix is optimised, therefore prone to overﬁtting otherwise).\nBut for models with discrete inputs such as words (where every word is mapped to a continuous\nvector – a word embedding) this is seldom done. With word embeddings the input can be seen as\neither the word embedding itself, or, more conveniently, as a “one-hot” encoding (a vector of zeros\nwith 1 at a single position). The product of the one-hot encoded vector with an embedding matrix\nWE ∈RV ×D (where D is the embedding dimensionality and V is the number of words in the\nvocabulary) then gives a word embedding. Curiously, this parameter layer is the largest layer in most\nlanguage applications, yet it is often not regularised. Since the embedding matrix is optimised it can\nlead to overﬁtting, and it is therefore desirable to apply dropout to the one-hot encoded vectors. This\nin effect is identical to dropping words at random throughout the input sentence, and can also be\ninterpreted as encouraging the model to not “depend” on single words for its output.\nNote that as before, we randomly set rows of the matrix WE ∈RV ×D to zero. Since we repeat the\nsame mask at each time step, we drop the same words throughout the sequence – i.e. we drop word\ntypes at random rather than word tokens (as an example, the sentence “the dog and the cat” might\nbecome “— dog and — cat” or “the — and the cat”, but never “— dog and the cat”). A possible\ninefﬁciency implementing this is the requirement to sample V Bernoulli random variables, where\nV might be large. This can be solved by the observation that for sequences of length T, at most T\nembeddings could be dropped (other dropped embeddings have no effect on the model output). For\nT ≪V it is therefore more efﬁcient to ﬁrst map the words to the word embeddings, and only then to\nzero-out word embeddings based on their word type.\n5 Experimental Evaluation\nWe start by implementing our proposed dropout variant into the Torch implementation of Zaremba\net al. [4], that has become a reference implementation for many in the ﬁeld. Zaremba et al. [4] have\nset a benchmark on the Penn Treebank that to the best of our knowledge hasn’t been beaten for\nthe past 2 years. We improve on [ 4]’s results, and show that our dropout variant improves model\nperformance compared to early-stopping and compared to using under-speciﬁed models. We continue\nto evaluate our proposed dropout variant with both LSTM and GRU models on a sentiment analysis\ntask where labelled data is scarce. We ﬁnish by giving an in-depth analysis of the properties of the\nproposed method, with code and many experiments deferred to the appendix due to space constraints.\n5.1 Language Modelling\nWe replicate the language modelling experiment of Zaremba, Sutskever, and Vinyals [4]. The\nexperiment uses the Penn Treebank, a standard benchmark in the ﬁeld. This dataset is considered\na small one in the language processing community, with 887,521 tokens (words) in total, making\noverﬁtting a considerable concern. Throughout the experiments we refer to LSTMs with the dropout\ntechnique proposed following our Bayesian interpretation as Variational LSTMs, and refer to existing\ndropout techniques as naive dropout LSTMs (eq. (8), different masks at different steps, applied to the\ninput and output of the LSTM alone). We refer to LSTMs with no dropout as standard LSTMs.\nWe implemented a Variational LSTM for both the medium model of [4] (2 layers with 650 units in\neach layer) as well as their large model (2 layers with 1500 units in each layer). The only changes\nwe’ve made to [4]’s setting are 1) using our proposed dropout variant instead of naive dropout, and\n2) tuning weight decay (which was chosen to be zero in [4]). All other hyper-parameters are kept\nidentical to [4]: learning rate decay was not tuned for our setting and is used following [4]. Dropout\nparameters were optimised with grid search (tying the dropout probability over the embeddings\ntogether with the one over the recurrent layers, and tying the dropout probability for the inputs and\noutputs together as well). These are chosen to minimise validation perplexity3. We further compared\nto Moon et al. [20] who only drop elements in the LSTM internal state using the same mask at all\n3Optimal probabilities are 0.3 and 0.5 respectively for the large model, compared [4]’s 0.6 dropout probability,\nand 0.2 and 0.35 respectively for the medium model, compared [4]’s 0.5 dropout probability.\n6Medium LSTM Large LSTM\nValidation Test WPS Validation Test WPS\nNon-regularized (early stopping) 121.1 121 .7 5 .5K 128.3 127 .4 2 .5K\nMoon et al. [20] 100.7 97 .0 4 .8K 122.9 118 .7 3 K\nMoon et al. [20] +emb dropout 88.9 86 .5 4 .8K 88.8 86 .0 3 K\nZaremba et al. [4] 86.2 82 .7 5 .5K 82.2 78 .4 2 .5K\nVariational (tied weights) 81.8 ±0.2 79 .7 ±0.1 4 .7K 77.3 ±0.2 75 .0 ±0.1 2 .4K\nVariational (tied weights, MC) − 79.0 ±0.1 − − 74.1 ±0.0 −\nVariational (untied weights) 81.9 ±0.2 79 .7 ±0.1 2 .7K 77.9 ±0.3 75 .2 ±0.2 1 .6K\nVariational (untied weights, MC) − 78.6 ±0.1 − − 73.4 ±0.0 −\nTable 1: Single model perplexity (on test and validation sets) for the Penn Treebank language\nmodelling task. Two model sizes are compared (a medium and a large LSTM, following [4]’s setup),\nwith number of processed words per second (WPS) reported. Both dropout approximation and MC\ndropout are given for the test set with the Variational model. A common approach for regularisation is\nto reduce model complexity (necessary with the non-regularised LSTM). With the Variational models\nhowever, a signiﬁcant reduction in perplexity is achieved by using larger models.\ntime steps (in addition to performing dropout on the inputs and outputs, eq. (9)). We implemented\ntheir dropout variant with each model size, and repeated the procedure above to ﬁnd optimal dropout\nprobabilities (0.3 with the medium model, and 0.5 with the large model). We had to use early stopping\nfor the large model with [20]’s variant as the model starts overﬁtting after 16 epochs. Moon et al.\n[20] proposed their dropout variant within the speech recognition community, where they did not\nhave to consider embeddings overﬁtting (which, as we will see below, affect the recurrent layers\nconsiderably). We therefore performed an additional experiment using [20]’s variant together with\nour embedding dropout (referred to as Moon et al. [20]+emb dropout).\nOur results are given in table 1. For the variational LSTM we give results using both the tied weights\nmodel (eq. (6)–(7), Variational (tied weights)), and without weight tying (eq. (5), Variational (untied\nweights)). For each model we report performance using both the standard dropout approximation\n(averaging the weights at test time – propagating the mean of each approximating distribution as input\nto the next layer), and using MC dropout (obtained by performing dropout at test time 1000 times,\nand averaging the model outputs following eq. (4), denoted MC). For each model we report average\nperplexity and standard deviation (each experiment was repeated 3 times with different random seeds\nand the results were averaged). Model training time is given in words per second (WPS).\nIt is interesting that using the dropout approximation, weight tying results in lower validation error\nand test error than the untied weights model. But with MC dropout the untied weights model performs\nmuch better. Validation perplexity for the large model is improved from [4]’s82.2 down to 77.3 (with\nweight tying), or 77.9 without weight tying. Test perplexity is reduced from 78.4 down to 73.4 (with\nMC dropout and untied weights). To the best of our knowledge, these are currently the best single\nmodel perplexities on the Penn Treebank.\nIt seems that Moon et al. [20] underperform even compared to [4]. With no embedding dropout the\nlarge model overﬁts and early stopping is required (with no early stopping the model’s validation\nperplexity goes up to 131 within 30 epochs). Adding our embedding dropout, the model performs\nmuch better, but still underperforms compared to applying dropout on the inputs and outputs alone.\nComparing our results to the non-regularised LSTM (evaluated with early stopping, giving similar\nperformance as the early stopping experiment in [4]) we see that for either model size an improvement\ncan be obtained by using our dropout variant. Comparing the medium sized Variational model to the\nlarge one we see that a signiﬁcant reduction in perplexity can be achieved by using a larger model.\nThis cannot be done with the non-regularised LSTM, where a larger model leads to worse results.\nThis shows that reducing the complexity of the model, a possible approach to avoid overﬁtting,\nactually leads to a worse ﬁt when using dropout.\nWe also see that the tied weights model achieves very close performance to that of the untied weights\none when using the dropout approximation. Assessing model run time though (on a Titan X GPU),\nwe see that tying the weights results in a more time-efﬁcient implementation. This is because the\nsingle matrix product is implemented as a single GPU kernel, instead of the four smaller matrix\n7products used in the untied weights model (where four GPU kernels are called sequentially). Note\nthough that a low level implementation should give similar run times.\nWe further experimented with a model averaging experiment following [4]’s setting, where several\nlarge models are trained independently with their outputs averaged. We used Variational LSTMs\nwith MC dropout following the setup above. Using 10 Variational LSTMs we improve [4]’s test set\nperplexity from 69.5 to 68.7 – obtaining identical perplexity to [4]’s experiment with 38 models.\nLastly, we report validation perplexity with reduced learning rate decay (with the medium model).\nLearning rate decay is often used for regularisation by setting the optimiser to make smaller steps\nwhen the model starts overﬁtting (as done in [4]). By removing it we can assess the regularisation\neffects of dropout alone. As can be seen in ﬁg. 2, even with early stopping, Variational LSTM achieves\nlower perplexity than naive dropout LSTM and standard LSTM. Note though that a signiﬁcantly\nlower perplexity for all models can be achieved with learning rate decay scheduling as seen in table 1\n5.2 Sentiment Analysis\nWe next evaluate our dropout variant with both LSTM and GRU models on a sentiment analysis task,\nwhere labelled data is scarce. We use MC dropout (which we compare to the dropout approximation\nfurther in appendix B), and untied weights model parametrisations.\nWe use the raw Cornell ﬁlm reviews corpus collected by Pang and Lee [27]. The dataset is composed\nof 5000 ﬁlm reviews. We extract consecutive segments ofT words from each review for T = 200,\nand use the corresponding ﬁlm score as the observed outputy. The model is built from one embedding\nlayer (of dimensionality 128), one LSTM layer (with 128 network units for each gate; GRU setting is\nbuilt similarly), and ﬁnally a fully connected layer applied to the last output of the LSTM (resulting\nin a scalar output). We use the Adam optimiser [28] throughout the experiments, with batch size 128,\nand MC dropout at test time with 10 samples.\nThe main results can be seen in ﬁg. 3. We compared Variational LSTM (with our dropout variant\napplied with each weight layer) to standard techniques in the ﬁeld. Training error is shown in ﬁg. 3a\nand test error is shown in ﬁg. 3b. Optimal dropout probabilities and weight decay were used for each\nmodel (see appendix B). It seems that the only model not to overﬁt is the Variational LSTM, which\nachieves lowest test error as well. Variational GRU test error is shown in ﬁg. 14 (with loss plot given\nin appendix B). Optimal dropout probabilities and weight decay were used again for each model.\nVariational GRU avoids overﬁtting to the data and converges to the lowest test error. Early stopping in\nthis dataset will result in smaller test error though (lowest test error is obtained by the non-regularised\nGRU model at the second epoch). It is interesting to note that standard techniques exhibit peculiar\nbehaviour where test error repeatedly decreases and increases. This behaviour is not observed with\nthe Variational GRU. Convergence plots of the loss for each model are given in appendix B.\nWe next explore the effects of dropping-out different parts of the model. We assessed our Variational\nLSTM with different combinations of dropout over the embeddings ( pE = 0,0.5) and recurrent\nlayers (pU = 0,0.5) on the sentiment analysis task. The convergence plots can be seen in ﬁgure 4a. It\nseems that without both strong embeddings regularisation and strong regularisation over the recurrent\nlayers the model would overﬁt rather quickly. The behaviour when pU = 0.5 and pE = 0is quite\ninteresting: test error decreases and then increases before decreasing again. Also, it seems that when\npU = 0and pE = 0.5 the model becomes very erratic.\nFigure 2: Medium model validation perplexity for the Penn Treebank language modelling task.\nLearning rate decay was reduced to assess model overﬁtting using dropout alone. Even with early\nstopping, Variational LSTM achieves lower perplexity than naive dropout LSTM and standard LSTM.\nLower perplexity for all models can be achieved with learning rate decay scheduling, seen in table 1.\n8(a) LSTM train error: variational,\nnaive dropout, and standard LSTM.\n(b) LSTM test error: variational,\nnaive dropout, and standard LSTM.\n(c) GRU test error: variational,\nnaive dropout, and standard LSTM.\nFigure 3: Sentiment analysis error for Variational LSTM / GRU compared to naive dropout LSTM /\nGRU and standard LSTM / GRU (with no dropout).\nLastly, we tested the performance of Variational LSTM with different recurrent layer dropout\nprobabilities, ﬁxing the embedding dropout probability at either pE = 0or pE = 0.5 (ﬁgs. 4b-4c).\nThese results are rather intriguing. In this experiment all models have converged, with the loss getting\nnear zero (not shown). Yet it seems that with no embedding dropout, a higher dropout probability\nwithin the recurrent layers leads to overﬁtting! This presumably happens because of the large number\nof parameters in the embedding layer which is not regularised. Regularising the embedding layer with\ndropout probability pE = 0.5 we see that a higher recurrent layer dropout probability indeed leads to\nincreased robustness to overﬁtting, as expected. These results suggest that embedding dropout can be\nof crucial importance in some tasks.\nIn appendix B we assess the importance of weight decay with our dropout variant. Common practice\nis to remove weight decay with naive dropout. Our results suggest that weight decay plays an\nimportant role with our variant (it corresponds to our prior belief of the distribution over the weights).\n6 Conclusions\nWe presented a new technique for recurrent neural network regularisation. Our RNN dropout variant\nis theoretically motivated and its effectiveness was empirically demonstrated. In future research\nwe aim to assess model uncertainty in Variational LSTMs [ 17]. Together with the developments\npresented here, this will have important implications for modelling language ambiguity and modelling\ndynamics in control tasks.\nReferences\n[1] Martin Sundermeyer, Ralf Schlüter, and Hermann Ney. LSTM neural networks for language modeling. In\nINTERSPEECH, 2012.\n[2] Nal Kalchbrenner and Phil Blunsom. Recurrent continuous translation models. In EMNLP, 2013.\n(a) Combinations of pE = 0, 0.5\nwith pU = 0, 0.5.\n(b) pU = 0, ...,0.5 with\nﬁxed pE = 0.\n(c) pU = 0, ...,0.5 with\nﬁxed pE = 0.5.\nFigure 4: Test error for Variational LSTM with various settings on the sentiment analysis task.\nDifferent dropout probabilities are used with the recurrent layer (pU ) and embedding layer (pE).\n9[3] Ilya Sutskever, Oriol Vinyals, and Quoc VV Le. Sequence to sequence learning with neural networks. In\nNIPS, 2014.\n[4] Wojciech Zaremba, Ilya Sutskever, and Oriol Vinyals. Recurrent neural network regularization. arXiv\npreprint arXiv:1409.2329, 2014.\n[5] Geoffrey E others Hinton. Improving neural networks by preventing co-adaptation of feature detectors.\narXiv preprint arXiv:1207.0580, 2012.\n[6] Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:\nA simple way to prevent neural networks from overﬁtting. JMLR, 2014.\n[7] Marius Pachitariu and Maneesh Sahani. Regularization and nonlinearities for neural language models:\nwhen are they needed? arXiv preprint arXiv:1301.5650, 2013.\n[8] Justin Bayer, Christian Osendorfer, Daniela Korhammer, Nutan Chen, Sebastian Urban, and Patrick van der\nSmagt. On fast dropout and its applicability to recurrent networks. arXiv preprint arXiv:1311.0701, 2013.\n[9] Vu Pham, Theodore Bluche, Christopher Kermorvant, and Jerome Louradour. Dropout improves recurrent\nneural networks for handwriting recognition. In ICFHR. IEEE, 2014.\n[10] Théodore Bluche, Christopher Kermorvant, and Jérôme Louradour. Where to apply dropout in recurrent\nneural networks for handwriting recognition? In ICDAR. IEEE, 2015.\n[11] Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic backpropagation and approxi-\nmate inference in deep generative models. In ICML, 2014.\n[12] Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in neural\nnetwork. In ICML, 2015.\n[13] Jose Miguel Hernandez-Lobato and Ryan Adams. Probabilistic backpropagation for scalable learning of\nBayesian neural networks. In ICML, 2015.\n[14] Yarin Gal and Zoubin Ghahramani. Bayesian convolutional neural networks with Bernoulli approximate\nvariational inference. arXiv:1506.02158, 2015.\n[15] Diederik Kingma, Tim Salimans, and Max Welling. Variational dropout and the local reparameterization\ntrick. In NIPS. Curran Associates, Inc., 2015.\n[16] Anoop Korattikara Balan, Vivek Rathod, Kevin P Murphy, and Max Welling. Bayesian dark knowledge.\nIn NIPS. Curran Associates, Inc., 2015.\n[17] Yarin Gal and Zoubin Ghahramani. Dropout as a Bayesian approximation: Representing model uncertainty\nin deep learning. arXiv:1506.02142, 2015.\n[18] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural computation, 9(8), 1997.\n[19] Kyunghyun Cho et al. Learning phrase representations using RNN encoder–decoder for statistical machine\ntranslation. In EMNLP, Doha, Qatar, October 2014. ACL.\n[20] Taesup Moon, Heeyoul Choi, Hoshik Lee, and Inchul Song. RnnDrop: A Novel Dropout for RNNs in\nASR. In ASRU Workshop, December 2015.\n[21] David JC MacKay. A practical Bayesian framework for backpropagation networks. Neural computation, 4\n(3):448–472, 1992.\n[22] Radford M Neal. Bayesian learning for neural networks. PhD thesis, University of Toronto, 1995.\n[23] Geoffrey E Hinton and Drew Van Camp. Keeping the neural networks simple by minimizing the description\nlength of the weights. In COLT, pages 5–13. ACM, 1993.\n[24] David Barber and Christopher M Bishop. Ensemble learning in Bayesian neural networks. NATO ASI\nSERIES F COMPUTER AND SYSTEMS SCIENCES, 168:215–238, 1998.\n[25] Alex Graves. Practical variational inference for neural networks. In NIPS, 2011.\n[26] Alan Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. Speech recognition with deep recurrent\nneural networks. In ICASSP. IEEE, 2013.\n[27] Bo Pang and Lillian Lee. Seeing stars: Exploiting class relationships for sentiment categorization with\nrespect to rating scales. In ACL. ACL, 2005.\n[28] Diederik Kingma and Jimmy Ba. Adam: A method for stochastic optimization. arXiv preprint\narXiv:1412.6980, 2014.\n[29] James Bergstra et al. Theano: a CPU and GPU math expression compiler. In Proceedings of the Python\nfor Scientiﬁc Computing Conference (SciPy), June 2010. Oral Presentation.\n[30] fchollet. Keras. https://github.com/fchollet/keras, 2015.\n10A Bayesian versus ensembling interpretation of dropout\nApart from our Bayesian approximation interpretation, dropout in deep networks can also be seen\nas following an ensembling interpretation [6]. This interpretation also leads to MC dropout at test\ntime. But the ensembling interpretation does not determine whether the ensemble should be over the\nnetwork units or the weights. For example, in an RNN this view will not lead to our dropout variant,\nunless the ensemble is deﬁned to tie the weights of the network ad hoc. This is in comparison to the\nBayesian approximation view where the weight tying is forced by the probabilistic interpretation of\nthe model.\nB Sentiment analysis – further experiments\nSentiment analysis hyper-parameters were obtained by evaluating each model with dropout probabili-\nties 0.25 and 0.5, and weight decays ranging from 10−6 to 10−4. The optimal setting for Variational\nLSTM is dropout probabilities 0.25 and weight decay 10−3, and for naive dropout LSTM the dropout\nprobabilities are 0.5 (no weight decay is used in reference implementations of naive dropout LSTM\n[4]).\nWe assess the dropout approximation in Variational LSTMs. The dropout approximation is often\nused in deep networks as means of approximating the MC estimate. In the approximation we replace\neach weight matrix M by pM where pis the dropout probability, and perform a deterministic pass\nthrough the network (without dropping out units). This can be seen as propagating the mean of the\nrandom variables W through the network [17]. The approximation has been shown to work well for\ndeep networks [6], yet it fails with convolution layers [14]. We assess the approximation empirically\nwith our Variational LSTM model, repeating the ﬁrst experiment with the approximation used at test\ntime instead of MC dropout. The results can be seen in ﬁg. 9. It seems that the approximation gives a\ngood estimate to the test error, similar to the results in ﬁgure 4a.\nWe further tested the Variational LSTM model with different weight decays, observing the effects of\ndifferent values for these. Note that weight decay is applied to all layers, including the embedding\nlayer. In ﬁgure 6 we can see that higher weight decay values result in lower test error, with signiﬁcant\ndifferences for different weight decays. This suggests that weight decay still plays an important role\neven when using dropout (whereas common practice is to remove weight decay with naive dropout).\nNote also that the weight decay can be optimised (together with the dropout parameters) as part of\nthe variational approximation. This is not done in practice in the deep learning community, where\ngrid-search or Bayesian optimisation are often used for these instead.\nTesting the Variational LSTM with different sequence lengths (with sequences of lengths T =\n20,50,200,400) we can see that sequence length has a strong effect on model performance as well\n(ﬁg. 7). Longer sequences result in much better performance but with the price of longer convergence\ntime. We hypothesised that the diminished performance on shorter sequences is caused by the high\ndropout probability on the embeddings. But a follow-up experiment with sequence lengths 50 and\n200, and different embedding dropout probabilities, shows that lower dropout probabilities result in\neven worse model performance (ﬁgures 8 and 5).\nIn ﬁg. 10a we see how different dropout probabilities and weight decays affect GRU model perfor-\nmance.\nFigure 5: pE = 0,..., 0.5 with\nﬁxed pU = 0.5.\nFigure 6: Test error for Vari-\national LSTM with different\nweight decays.\nFigure 7: Variational\nLSTM test error for dif-\nferent sequence lengths\n(T = 20 ,50,200,400\ncut-offs).\n11Figure 8: Test error for various\nembedding dropout probabili-\nties, with sequence length 50.\nFigure 9: Dropout approxima-\ntion in Variational LSTM with\ndifferent dropout probabilities.\n(a) Various Variational GRU model conﬁgurations\nFigure 10: Sentiment analysis error for Variational GRUcompared to naive dropout GRUand\nstandard GRU(with no dropout). Test error for the different models (left) and for different Varia-\ntional GRU conﬁgurations (right).\nWe compare naive dropout LSTM to Variational LSTM with dropout probability in the recurrent\nlayers set to zero: pU = 0(referred to as dropout LSTM). Both models apply dropout to the input and\noutputs of the LSTM alone, with no dropout applied to the embeddings. Naive dropout LSTM uses\ndifferent masks at different time steps though, tied across the gates, whereas dropout LSTM uses the\nsame mask at different time steps. The test error for both models can be seen in ﬁg. 11. It seems that\nwithout dropout over the recurrent layers and embeddings both models overﬁt, and in fact result in\nidentical performance.\nNext, we assess the dropout approximation in the GRU model. The approximation seems to give\nsimilar results to MC dropout in the GRU model (ﬁg. 12).\nFigure 11: Naive dropout LSTM uses different\ndropout masks at each time step, whereasDropout\nLSTM uses the same mask at each time step. Both\nmodels apply dropout to the inputs and outputs\nalone, and result in identical performance.\nFigure 12: GRU dropout approximation\n12Lastly, we plot the train loss for various models from the main body of the paper. All models have\nconverged, with a stable train loss.\nFigure 13: Train loss (as a func-\ntion of batches) for ﬁgure 3a\nFigure 14: GRU train loss (as a\nfunction of batches) (ﬁgure 14)\nFigure 15: Train loss (as a func-\ntion of batches) for ﬁgure 4a\n13C Code\nAn efﬁcient Theano [29] implementation of the method above into Keras [30] is as simple as:\ndef get_output(self, train=False):\nX = self.get_input(train)\nretain_prob_W = 1. - self.p_W[0]\nretain_prob_U = 1. - self.p_U[0]\nB_W = self.srng.binomial((4, X.shape[1], self.input_dim),\np=retain_prob_W, dtype=theano.config.floatX)\nB_U = self.srng.binomial((4, X.shape[1], self.output_dim),\np=retain_prob_U, dtype=theano.config.floatX)\nxi = T.dot(X * B_W[0], self.W_i) + self.b_i\nxf = T.dot(X * B_W[1], self.W_f) + self.b_f\nxc = T.dot(X * B_W[2], self.W_c) + self.b_c\nxo = T.dot(X * B_W[3], self.W_o) + self.b_o\n[outputs, memories], updates = theano.scan(\nself._step,\nsequences=[xi, xf, xo, xc],\noutputs_info=[\nT.unbroadcast(alloc_zeros_matrix(X.shape[1], self.output_dim), 1),\nT.unbroadcast(alloc_zeros_matrix(X.shape[1], self.output_dim), 1)\n],\nnon_sequences=[self.U_i, self.U_f, self.U_o, self.U_c, B_U],\ntruncate_gradient=self.truncate_gradient)\nreturn outputs[-1]\ndef _step(self,\nxi_t, xf_t, xo_t, xc_t,\nh_tm1, c_tm1,\nu_i, u_f, u_o, u_c, B_U):\ni_t = self.inner_activation(xi_t + T.dot(h_tm1 * B_U[0], u_i))\nf_t = self.inner_activation(xf_t + T.dot(h_tm1 * B_U[1], u_f))\nc_t = f_t * c_tm1 + i_t * self.activation(xc_t + T.dot(h_tm1 * B_U[2], u_c))\no_t = self.inner_activation(xo_t + T.dot(h_tm1 * B_U[3], u_o))\nh_t = o_t * self.activation(c_t)\nreturn h_t, c_t\n14"
    }
}